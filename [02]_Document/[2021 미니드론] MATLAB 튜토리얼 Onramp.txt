# 2.1장 명령 입력하기
1) 명령 3*5를 입력하여 숫자 3과 5를 곱하세요.
3 * 5

2) 다음과 같이 입력하여 변수 m에 3*5 계산 결과를 할당하세요.
m = 3*5

3) 명령 m = m + 1을 입력하여 어떤 동작이 발생하는지 확인하세요.
m = m + 1

4) 값이 m/2인 변수 y를 만드세요.
y = m / 2

5) k = 8 - 2;을 입력하여 명령 맨 끝에 세미콜론을 추가하세요.
명령 창에는 실행 결과가 표시되지 않지만 작업 공간 창에서 해당 값을 확인할 수 있습니다.
k = 8 - 2;

6) 위쪽 화살표 키를 눌러 명령 m = 3*5를 되돌아간 다음
이 명령을 편집하여 m = 3*k로 수정하세요.
m = 3 * k

7) 앞부분에서 m을 사용하여 y의 값을 계산했습니다. m이 수정되었을 때 y도 다시 계산되었을까요?
명령 창에 변수 이름 y만 입력하고 Enter 키를 눌러 보세요.
y

추가실습) MATLAB은 명령 창에 있는 이전 명령을 다시 실행하지 않기 때문에 y의 값이 변경되지 않았습니다. m이 수정된 후 y를 다시 계산하려면 명령 y = m/2를 다시 실행해야 합니다.
지금 다시 한 번 해 보세요. 위쪽 화살표 키를 사용하여 명령 y = m/2를 다시 불러온 다음
Enter 키를 누르세요. y의 새 값을 표시하려면 명령의 맨 끝에 세미콜론을 사용하지 않아야 합니다.
y = m / 2

--------------------------------------------------------------------------------------------------------------------
# 2.2장 변수 이름 지정하기
1) 값 -2를 변수 A에 할당하세요.
A = -2

2) a+A / 2를 계산하세요. 그 결과를 변수 avgAa에 할당하세요.
avgAa = (a + A) / 2

추가실습) 유효하지 않은 변수 이름을 사용하면 MATLAB에서 정정 사항을 제안합니다.
제안된 명령을 그대로 사용하거나 수정할 수 있으며, Esc 키를 눌러 이 제안을 삭제할 수 있습니다.
변수 3sq = 9를 만들어 이 동작을 직접 확인해 보세요.
3sq = 9
>> sq = 9

--------------------------------------------------------------------------------------------------------------------


==================================================================
# 7.1장 함수에서 여러 개의 출력값 구하기
1) data 변수의 크기를 포함하는 변수 dsize를 만드세요.
dsize = size(data)

2) 변수 data의 행 개수와 열 개수를 각각 포함하는 변수 dr 및 dc를 만드세요.
[dr, dc] = size(data)

3) v2 벡터의 최댓값과 이에 해당하는 인덱스 값을 각각 포함하는 변수 vMax 및 ivMax를 만드세요.
[vMax, ivMax] = max(v2)

추가학습) v2에서 최솟값의 인덱스 값을 구해 보세요. 이 인덱스를 사용하여 density에서 값을 추출해 보세요.
density = v2
[~, ivMin] = min(v2)
density(ivMin)

==================================================================
# 8.1장 도움말 보기(실습)
1) randi에 대한 도움말 문서를 참조하여 아래 작업을 완료하세요.
    다음과 같은 행렬 x를 만드세요.
    1부터 20까지의 임의의 정수를 포함함
    5개 행을 가짐
    7개 열을 가짐
x = randi(20, 5, 7)

추가실습) 또한, doc 함수를 사용하여 도움말 문서를 열 수도 있습니다.
아래 코드를 사용하여 randi에 대한 도움말 문서를 열어 보세요.
doc 정규분포된 난수
randn(5, 7)

==================================================================
# 9.1장 벡터 플로팅
1) x축이 sample이고 y축이 mass1인 플롯을 생성하세요.
plot(sample, mass1)

2) sample(x축)에 대해 mass2(y축)를 플로팅하세요.
이때 플롯에 선은 그리지 않고 빨간색(r) 별 마커(*)만 표시되도록 하세요.
plot(sample, mass2, "r*")

3) hold on 명령을 입력하세요.
그런 다음 sample(x축)에 대해 mass1(y축)을 플로팅하세요.
이때 선은 그리지 않고 검은색(k) 정사각형 마커(s)만 표시되도록 하세요.
hold on
plot(sample, mass1, "ks")

4) hold off 명령을 입력하세요.
hold off

5) 아래 명령을 사용하여 벡터 v1을 플로팅하세요.
plot(v1)

6) 선 너비를 3으로 지정하여 v1을 플로팅하세요.
plot(v1, "LineWidth", 3)

7) sample(x축)에 대해 v1(y축)을 플로팅하세요.
선 너비를 4로 지정하고 빨간색(r) 원 마커(o)를 사용하세요.
plot(sample, v1, "ro", "LineWidth", 4)

8) histogram 함수를 사용하여 density의 히스토그램을 생성해 보세요.
"FaceColor"를 노란색("y")으로 설정하세요.
histogram(density,"FaceColor","y")	% 확실하지 않음

--------------------------------------------------------------------------------------------------------------------
# 9.2장 플롯에 주석 달기
1) 플롯에 "Sample Mass"라는 제목을 추가하세요.
title("Sample Mass")

2) ylabel 함수를 사용하여 "Mass (g)"라는 레이블을 추가하세요.
ylabel("Mass (g)")

3) 레이블 "Exp A" 및 "Exp B"를 차례로 지정하여 범례를 만드세요.
legend("Exp A", "Exp B")

추가실습) 플롯에 주석을 달 때 문자열과 변수를 결합하면 변수의 값을 사용할 수 있습니다.
bar(data(3,:))
title("Sample " + sample(3) + " Data")

==================================================================
# 10.1장 프로젝트 - 전력 사용량
이 프로젝트에서는 다양한 경제 부문(주거, 상업 및 공업)의 전력 사용량을 플로팅해 봅니다. 어느 경제 부문의 사용량이 가장 클 것으로 생각하시나요?
이 프로젝트에서는 매년 7월에 수집된 미국의 전력 사용량 데이터를 사용합니다. 사용량 데이터의 단위는 109kWh/day이며, 가격 데이터의 단위는 US cents/kWh입니다.

1) 전력 데이터가 electricity.mat 파일에 저장되어 있습니다. MAT 파일을 MATLAB으로 불러오세요.
그런 다음 스크립트에 usage를 입력하여 행렬을 표시하세요.
load electricity
usage

2) usage 변수에 포함된 요소 중 하나의 값이 NaN입니다. 이 값을 값 2.74로 바꾸세요.
usage(2, 3) = 2.74

3) 주거 데이터가 첫 번째 열에 저장되어 있습니다.
usage의 첫 번째 열을 포함하는 변수 res를 만드세요.
res = usage(:, 1)

4) 상업 데이터와 공업 데이터가 두 번째 열과 세 번째 열에 각각 저장되어 있습니다.
usage의 두 번째 열과 세 번째 열을 포함하는 변수 comm과 ind를 만드세요.
comm = usage(:, 2)
ind = usage(:, 3)

5) 1991년부터 2013년까지의 연도를 나타내는 벡터 yrs를 만드세요.
yrs = (1991:2013)

6) 세 열에 대한 플롯을 만드세요. yrs를 x 데이터로 사용하고 다음 플롯 사양을 순서대로 사용하세요.
res: 파란색(b) 파선(--)
comm: 검은색(k) 점선(:)
ind: 자홍색(m) 일점 쇄선(-.)

hold on
plot(yrs, res, "b--")
plot(yrs, comm, "k:")
plot(yrs, ind, "m-.")

7) "July Electricity Usage"라는 제목을 기존 플롯에 추가하세요.
값 "res", "comm", "ind"를 범례로 만드세요.
title("July Electricity Usage")
legend("res", "comm", "ind")

추가실습) Figure를 살펴보면 공업 부문의 전력 사용량이 꽤 일관되며
거주 및 상업 부문에 비해 변동이 크지 않다는 것을 알 수 있습니다.
-> 그냥 plot 결과를 보고 분석한 것임, 별도의 코드는 없음

--------------------------------------------------------------------------------------------------------------------
# 10.2장 프로젝트 - 오디오 주파수
오디오 신호는 일반적으로 서로 다른 여러 주파수로 구성됩니다.
예를 들어, 음악에서 '가온다(middle C)' 음의 기본 주파수는 261.6Hz이며,
대부분의 음악은 동시에 연주되는 여러 음 즉, 주파수로 구성됩니다.

이 프로젝트에서는 C 코드를 연주하는 오르간의 주파수 성분을 분석해 봅니다.
C 코드는 C(261.6Hz), E(329.6Hz), G(392.0Hz)로 구성됩니다.
주파수 플롯에서 강조 표시된 점은 각 음에 해당합니다.

1) 파일 Cchord.mat를 불러오세요. y에 포함된 요소의 개수를 나타내는 변수 n을 만드세요.
그런 다음 n을 사용하여 0에서 n-1까지 요소 간격이 1인 벡터 t를 만드세요.
load Cchord
n = numel(y)
t = (0:n-1)

2) t를 fs로 나누고 해당 출력값을 다시 t에 할당하세요. 그런 다음 t에 대해 y를 플로팅하세요.
t = t / fs
plot(t, y)

3) y의 이산 푸리에 변환에 대한 절댓값을 포함하는 변수 yfft를 만드세요.
yfft = abs(fft(y))

4) 0에서 n-1까지 요소 간격이 1인 벡터 f를 만드세요.
f = (0:n-1)

5) f를 fs/n와 곱하고 그 출력값을 다시 f에 할당하세요.
x축 제한으로 0~1000을 지정하여 f에 대해 yfft를 플로팅하세요.
f = f * fs / n
plot(f, yfft)
xlim([0 1000])

추가실습) 출력 창에서 데이터 커서를 사용하여 주파수 위치를 확인하세요.
-> 플롯창에 마우스커서를 댄 후 "데이터 팁" 도구를 클릭한 다음 그래프를 클릭

==================================================================
# 11.1장 가져오기 툴
1) elements.Density의 내용을 열 벡터 d에 할당하세요.
d = elements.Density

2) elements.Density의 각 요소를 elements.Volume1과 곱하세요. .*를 사용해야 합니다.
결과를 elements.Mass에 할당하세요.
elements.Mass = elements.Density .* elements.Volume1

3) 가장 작은 질량부터 가장 큰 질량 순으로 테이블을 정렬하세요.
그런 다음, 스크립트에서 코드를 업데이트하고 제출하기를 클릭하세요.
-> 출력창에서 기준열 클릭 - 아래삼각형 클릭 - 오름차순 정렬 - 코드 업데이트 클릭

4) 다음을 실행하여 테이블의 처음 3개 행을 추출해 보세요.
top3도 테이블임을 확인할 수 있습니다.
top3 = elements(1:3,:)

==================================================================
# 12.1장 논리형 인덱싱
1) 관계 연산자 <을 사용하여 π가 4보다 작은지 테스트하세요. 그 출력값을 변수 test에 할당하세요.
test = pi < 4

2) 벡터 v1의 요소가 4보다 작은지 테스트하세요. 그 출력값을 변수 test에 할당하세요.
test = v1 < 4

3) 4보다 작은 v1의 요소를 모두 포함하는 변수 v를 만드세요.
v = v1(v1 < 4)

4) 4보다 작은 v1의 요소들과 같은 위치에 있는 sample의 요소들을 포함하는 변수 s를 만드세요.
s = sample(v1 < 4)

5) 4보다 작은 모든 값이 값 0으로 대체되도록 v1을 수정하세요.
v1(v1 < 4) = 0

추가실습) 논리 연산자 and(&) 및 or(|)을 사용하여 여러 논리 비교를 결합할 수 있습니다.
4보다 작고 그리고 2보다 큰 값을 찾으려면 &를 사용하세요.
-> x = v1(v1<4 & v1>2)
6보다 크거나 또는 2보다 작은 값을 찾으려면 |을 사용하세요.
-> x = v1(v1>6 | v1<2)
sample에서 10과 20 사이의 값을 구해 보세요.
-> x = sample(10 <= sample & sample <= 20)

==================================================================
# 13.2장 의사 결정 분기
1) doPlot이 1인 경우에만 플로팅을 위한 4-7번 라인의 코드가 실행되도록 스크립트를 수정하세요.
if doPlot == 1
    plot(density)
    title("Sample Densities")
    xticklabels(element)
    ylabel("Density (g/cm^3)")
end

2) if 조건이 충족되지 않는 경우 다음 코드 라인이 실행되도록 스크립트를 수정하세요.
disp("The density of " + element ...
    + " is " + density)

if doPlot == 1
    plot(density)
    title("Sample Densities")
    xticklabels(element)
    ylabel("Density (g/cm^3)")
else
    disp("The density of " + element ...
        + " is " + density)
end

추가실습) if 뒤에 elseif 키워드를 사용하여 조건을 추가할 수 있습니다.
여러 개의 elseif 블록을 포함할 수 있습니다.
변수 doDisplay를 추가하여 density 표시 여부를 전환해 보세요.
elseif 블록을 사용하여 이 조건을 추가해 보세요.

doDisplay = 0		% 확실하지 않음
if doDisplay == 1
    plot(density)
elseif doDisplay == 0
    density
end

--------------------------------------------------------------------------------------------------------------------
# 13.3장 for 루프
1) 코드가 7번 실행되도록 라이브 스크립트의 두 번째 섹션(4~7번 라인)에 있는 코드를 루프로 감싸세요. 루프 카운터의 이름을 idx로 지정하세요. 루프를 처음 실행할 때 idx의 값은 1이 되고 매 반복마다 1씩 증가합니다.
for idx = 1:7
    hold on
    plot(idx,density(idx),'*')
    hold off
    pause(0.2)
end

추가실습) 플롯이 움직이는 걸 보셨나요? 코드 pause(0.2)를 실행하면 플롯이 업데이트되도록 0.2초 동안 루프가 중지됩니다. 값 0.2를 증가시켜 애니메이션 시간을 늘려 보세요.
density 벡터의 요소가 7개이므로 루프는 7번 실행됩니다.
길이를 알 수 없는 벡터를 사용해 루프를 실행하려는 경우 length 함수를 대신 사용할 수 있습니다.
for idx = 1:length(density)
    hold on
    plot(idx,density(idx),'*')
    hold off
    pause(0.5)
end

==================================================================
# 14.1장 프로젝트 - 별의 운동
1) 기록된 스펙트럼의 마지막 파장 값을 포함하는 변수 lambdaEnd(λend)를 만드세요.
수식 λstart+(nObs−1)λdelta를 사용하여 lambdaEnd를 계산할 수 있습니다.
lambdaEnd를 사용하여 스펙트럼에서 λstart부터 λend까지 스텝이 λdelta인
파장들을 포함하는 열 벡터 lambda(λ)를 만드세요.

lambdaEnd = lambdaStart + (nObs - 1) * lambdaDelta
lambda = (lambdaStart:lambdaDelta:lambdaEnd)'

2) spectra의 여섯 번째 열을 벡터 s로 추출하세요.
s = spectra(:, 6)

3) 두 축 모두에 로그 스케일을 사용하여 파장(lambda)의 함수로 스펙트럼(s)을 플로팅하세요.
점 마커(.)를 사용하고 실선(-)으로 점을 연결하세요.
x 레이블 "Wavelength"와 y 레이블 "Intensity"를 플롯에 추가하세요.

loglog(lambda, s, ".-")
xlabel("Wavelength")
ylabel("Intensity")

4) s의 최솟값과 최솟값이 발생한 인덱스를 각각 포함하는 두 개의 변수 sHa와 idx를 만드세요.
idx를 사용하여 lambda의 요소를 참조해 알파 수소(Hydrogen-alpha) 선의 파장을 구하세요.
결과를 lambdaHa(λHa)로 저장하세요.

[sHa, idx] = min(s)
lambdaHa = lambda(idx)

5) x = lambdaHa, y = sHa를 마커 크기("MarkerSize")가 8인
빨간색 정사각형("rs")으로 플로팅하여 점을 기존 그래프에 추가하세요.
hold on
plot(lambdaHa, sHa, "rs", "MarkerSize", 8)

6) 적색편이 인자와 별이 지구로부터 멀어지는 속도(단위: km/s)를 계산하세요.
적색편이 인자를 변수 z에 할당하고 속도를 변수 speed에 할당하세요.
별의 알파 수소 파장을 사용하면 수식 z=(λHa/656.28)−1을 사용하여 적색편이 인자(지구에 상대적인 별의 속도)를 계산할 수 있습니다. 그러면 적색편이 인자를 빛의 속도(299792.458km/s)와 곱하여 속도를 계산할 수 있습니다.

z = (lambdaHa / 656.28) - 1
speed = z * 299792.458

7) spectra에서 여섯 번째 별 대신 두 번째 별에 대한 적색편이를 계산하도록
스크립트의 작업 2 및 7 섹션을 수정하세요.
s = spectra(:, 2)

추가실습) 인덱스 값을 변경하는 대신 슬라이더를 사용하여 spectra에서 임의의 열을 선택해 보세요.
슬라이더를 추가한 후 마우스 오른쪽 버튼으로 클릭하여 슬라이더 값을 구성하면 됩니다.
값이 spectra의 각 열을 거쳐야 합니다. 즉, 값을 1:1:10으로 구현해야 합니다.
-> 상단의 도구모음 - 코드 탭 - 컨트롤 - 숫자 슬라이더 - 최대/최소/간격 설정 - 출력창에서 수정클릭
s = spectra(:, 6)*2

--------------------------------------------------------------------------------------------------------------------
# 14.2장 프로젝트 – 별의 운동 II
1) 스크립트의 2번 라인을 수정하세요. 모든 별의 속도를 계산하도록 (:,2)를 삭제하세요.
[sHa,idx] = min(spectra);
lambdaHa = lambda(idx);
z = lambdaHa/656.28 - 1;
speed = z*299792.458

2) 루프 인덱스가 c인 for 루프를 만드세요. 루프 인덱스는 spectra의 모든 열(1~7)을 거쳐야 합니다.
루프 본문에서 spectra의 c번째 열을 s라는 이름의 변수로 추출하세요.
for c = 1:7
    s = spectra(:, c)
end

3) if 문을 for 루프 본문에 추가하세요. speed(c)가 0보다 작거나 같을 경우 파선(--)을 사용하여 lambda에 대한 s의 loglog 플롯을 만드세요.
하나의 플롯만 생성되도록 if 문 뒤에 hold on 명령을 추가하세요.
for c = 1:7
    s = spectra(:, c)
    if speed(c) <= 0
        hold on
        loglog(lambda, s, "--")
    end
end

4) else 문을 추가하세요. speed(c)가 0보다 클 경우 선 너비를 3으로 지정하여 lambda에 대한 s의 loglog 플롯을 만드세요. for 루프가 완료된 후 hold off를 입력하세요.
for c = 1:7
    s = spectra(:, c)
    if speed(c) <= 0
        hold on
        loglog(lambda, s, "--")
    else
        loglog(lambda, s, "LineWidth", 3)
    end
end
hold off

5) 배열 starnames를 사용하여 플롯에 범례를 추가하세요.
legend(starnames)

6) 0보다 큰 speed의 요소들과 같은 위치에 있는
starnames의 요소들을 포함하는 변수 movaway를 만드세요.
movaway = starnames(speed > 0)

추가실습) 완료하셨습니다!
다음 페이지에는 본 교육과정에서 설명한 모든 개념이 요약되어 있습니다.